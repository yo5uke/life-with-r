{
  "hash": "d46d5a3d14ead080a9c1143272ffd1c7",
  "result": {
    "engine": "knitr",
    "markdown": "# データハンドリング応用 - dplyr発展\n\n前章で`select()`, `filter()`, `arrange()`を学びました。この章では、さらに強力なデータ操作の方法を学びます。\n\n実務でのデータ分析では、新しい列を作成したり、データを集計したりすることが頻繁にあります。`dplyr`の`mutate()`, `summarize()`, `group_by()`を使うと、これらの操作を簡単に実行できます。\n\n## 学習内容\n\nこの章を読み終えると、以下ができるようになります。\n\n- `mutate()`: 新しい列を作成する\n- `summarize()`: データを要約する\n- `group_by()`: グループごとに集計する\n- `count()`: データを数える\n- これらを組み合わせた実践的なデータ分析\n\n## データの準備\n\n引き続き`iris`データセットを使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ndata(iris)\n```\n:::\n\n\n## mutate(): 新しい列を作成する\n\n`mutate()`関数は、既存の列を使って新しい列を作成したり、既存の列を変換したりします。\n\n### 基本的な使い方\n\n`mutate()`内で新しい列名を指定し、その列に代入する値を計算式で書きます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# がく片の面積を計算して新しい列として追加\nresult <- iris |>\n  mutate(Sepal.Area = Sepal.Length * Sepal.Width) |>\n  select(Species, Sepal.Length, Sepal.Width, Sepal.Area) |>\n  head()\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Species Sepal.Length Sepal.Width Sepal.Area\n1  setosa          5.1         3.5      17.85\n2  setosa          4.9         3.0      14.70\n3  setosa          4.7         3.2      15.04\n4  setosa          4.6         3.1      14.26\n5  setosa          5.0         3.6      18.00\n6  setosa          5.4         3.9      21.06\n```\n\n\n:::\n:::\n\n\n### 複数の列を一度に作成\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 複数の計算を一度に実行\nresult <- iris |>\n  mutate(\n    Sepal.Area = Sepal.Length * Sepal.Width,\n    Petal.Area = Petal.Length * Petal.Width,\n    Total.Area = Sepal.Area + Petal.Area\n  ) |>\n  select(Species, Sepal.Area, Petal.Area, Total.Area)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Species Sepal.Area Petal.Area Total.Area\n1  setosa      17.85       0.28      18.13\n2  setosa      14.70       0.28      14.98\n3  setosa      15.04       0.26      15.30\n4  setosa      14.26       0.30      14.56\n5  setosa      18.00       0.28      18.28\n6  setosa      21.06       0.68      21.74\n```\n\n\n:::\n:::\n\n\n### 条件による値の変更\n\n`if_else()`や`case_when()`を使うと、条件に応じて値を変更できます。\n\n`if_else()`は、第1引数に条件、第2引数に条件がTRUEの場合の値、第3引数に条件がFALSEの場合の値を指定します。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthが5以上なら\"大きい\"、そうでなければ\"小さい\"\nresult <- iris |>\n  mutate(\n    Size = if_else(Sepal.Length >= 5, \"大きい\", \"小さい\")\n  ) |>\n  select(Species, Sepal.Length, Size)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Species Sepal.Length   Size\n1  setosa          5.1 大きい\n2  setosa          4.9 小さい\n3  setosa          4.7 小さい\n4  setosa          4.6 小さい\n5  setosa          5.0 大きい\n6  setosa          5.4 大きい\n```\n\n\n:::\n:::\n\n\n複数の条件がある場合は`case_when()`が便利です。`TRUE`は、上の条件に当てはまらない場合の値を指定するために使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthを3段階に分類\niris |>\n  mutate(\n    Size_Category = case_when(\n      Sepal.Length < 5 ~ \"小\",\n      Sepal.Length < 6 ~ \"中\",\n      TRUE ~ \"大\"  # それ以外（上の条件に当てはまらない場合）\n    )\n  ) |>\n  select(Species, Sepal.Length, Size_Category) |>\n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Species Sepal.Length Size_Category\n1   setosa          5.1            中\n2   setosa          4.9            小\n3   setosa          4.7            小\n4   setosa          4.6            小\n5   setosa          5.0            中\n6   setosa          5.4            中\n7   setosa          4.6            小\n8   setosa          5.0            中\n9   setosa          4.4            小\n10  setosa          4.9            小\n```\n\n\n:::\n:::\n\n\n## summarize(): データを要約する\n\n`summarize()`（または`summarise()`）関数は、データを集約して要約統計量を計算します。\n\n`mutate()`の場合と同様に、`summarize()`内で新しい列名を指定し、その列に代入する値を計算式で書きます。\n\n### 基本的な統計量\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# がく片の長さの平均値を計算\niris |>\n  summarize(\n    mean = mean(Sepal.Length)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      mean\n1 5.843333\n```\n\n\n:::\n:::\n\n\n### 複数の統計量を一度に計算\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 複数の統計量を計算\niris |>\n  summarize(\n    mean = mean(Sepal.Length),\n    median = median(Sepal.Length),\n    sd = sd(Sepal.Length),\n    minimum = min(Sepal.Length),\n    maximum = max(Sepal.Length),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      mean median        sd minimum maximum   n\n1 5.843333    5.8 0.8280661     4.3     7.9 150\n```\n\n\n:::\n:::\n\n\n::: {.callout-note}\n## よく使う集計関数\n\n- `mean()`: 平均値\n- `median()`: 中央値\n- `sd()`: 標準偏差\n- `var()`: 分散\n- `min()`: 最小値\n- `max()`: 最大値\n- `sum()`: 合計\n- `n()`: 行数を数える\n- `n_distinct()`: ユニークな値の数\n:::\n\n## group_by(): グループごとに集計する\n\n`group_by()`と`summarize()`を組み合わせると、**グループごとの集計**ができます。これが非常に強力です。\n\n### 基本的な使い方\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 品種ごとにがく片の長さの平均を計算\niris |>\n  group_by(Species) |>\n  summarize(\n    mean = mean(Sepal.Length)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  Species     mean\n  <fct>      <dbl>\n1 setosa      5.01\n2 versicolor  5.94\n3 virginica   6.59\n```\n\n\n:::\n:::\n\n\n### 複数の統計量をグループごとに計算\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 品種ごとに複数の統計量を計算\niris |>\n  group_by(Species) |>\n  summarize(\n    n = n(),\n    mean = mean(Sepal.Length),\n    sd = sd(Sepal.Length),\n    minimum = min(Sepal.Length),\n    maximum = max(Sepal.Length)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 6\n  Species        n  mean    sd minimum maximum\n  <fct>      <int> <dbl> <dbl>   <dbl>   <dbl>\n1 setosa        50  5.01 0.352     4.3     5.8\n2 versicolor    50  5.94 0.516     4.9     7  \n3 virginica     50  6.59 0.636     4.9     7.9\n```\n\n\n:::\n:::\n\n\n### グループ化したまま新しい列を作成\n\n`mutate()`と組み合わせると、グループごとの計算結果を元のデータに追加できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 品種ごとの平均値を各行に追加\nresult <- iris |>\n  group_by(Species) |>\n  mutate(\n    Species_Mean = mean(Sepal.Length),\n    Diff_from_Mean = Sepal.Length - Species_Mean\n  ) |>\n  select(Species, Sepal.Length, Species_Mean, Diff_from_Mean)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   Species [1]\n  Species Sepal.Length Species_Mean Diff_from_Mean\n  <fct>          <dbl>        <dbl>          <dbl>\n1 setosa           5.1         5.01        0.0940 \n2 setosa           4.9         5.01       -0.106  \n3 setosa           4.7         5.01       -0.306  \n4 setosa           4.6         5.01       -0.406  \n5 setosa           5           5.01       -0.00600\n6 setosa           5.4         5.01        0.394  \n```\n\n\n:::\n:::\n\n\nページの都合上Speciesがsetosaしか表示されていませんが、virginicaとversicolorも同様に平均値と平均との差分が計算されます。ポイントは、`mutate()`はグループ化した状態で計算するため、同じ品種の行はそれぞれ同じ平均値が入ることです。\n\n::: {.callout-caution}\n## ungroup()を忘れずに\n\n`group_by()`を使った後、グループ化を解除したい場合は`ungroup()`を使います。\n\n```r\niris |>\n  group_by(Species) |>\n  summarize(平均 = mean(Sepal.Length)) |>\n  ungroup()  # グループ化を解除\n```\n\nグループ化したまま次の操作を行うと、予期しない結果になることがあるため注意が必要です。グループ化して計算したい範囲が終わったら、`ungroup()`でグループ化を解除する習慣をつけましょう。\n:::\n\n### `.by`引数でグループ化と集計を同時に行う\n\n`group_by()`と`summarize()`を組み合わせる代わりに、`summarize()`の`.by`引数を使うと、グループ化と集計を同時に行うことができます。\n\n関数内でのみグループ化が行われるため、先述した`ungroup()`を使う必要もなく、コードがシンプルになります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# .by引数を使ってグループ化と集計を同時に\niris |>\n  summarize(\n    n = n(),\n    mean = mean(Sepal.Length),\n    sd = sd(Sepal.Length),\n    minimum = min(Sepal.Length),\n    maximum = max(Sepal.Length),\n    .by = Species\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Species  n  mean        sd minimum maximum\n1     setosa 50 5.006 0.3524897     4.3     5.8\n2 versicolor 50 5.936 0.5161711     4.9     7.0\n3  virginica 50 6.588 0.6358796     4.9     7.9\n```\n\n\n:::\n:::\n\n\nちなみに`.by`引数は、`summarize()`以外にも`mutate()`や`filter()`などでも使えます。グループ化と集計を同時に行いたい場合は、`.by`引数を活用してコードをシンプルにすることも検討してみてください。\n\n## count(): データを数える\n\n`count()`関数は、値の出現回数を簡単に数えられます。\n\n### 基本的な使い方\n\n以下の例では、`Species`ごとにデータの数を数えています。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 品種ごとのデータ数を数える\niris |>\n  count(Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Species  n\n1     setosa 50\n2 versicolor 50\n3  virginica 50\n```\n\n\n:::\n:::\n\n\nこれは以下と同じ意味です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\niris |>\n  group_by(Species) |>\n  summarize(n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  Species        n\n  <fct>      <int>\n1 setosa        50\n2 versicolor    50\n3 virginica     50\n```\n\n\n:::\n:::\n\n\n## 実践例：売上データの分析\n\n実務でよくある売上データの分析を例に、これまでの知識を総合的に使ってみましょう。\n\n### サンプルデータの作成\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 売上データの作成\nsales <- data.frame(\n  日付 = rep(c(\"2025-01-01\", \"2025-01-02\", \"2025-01-03\"), each = 4),\n  店舗 = rep(c(\"東京店\", \"大阪店\", \"東京店\", \"大阪店\"), 3),\n  商品 = rep(c(\"商品A\", \"商品A\", \"商品B\", \"商品B\"), 3),\n  売上数量 = c(10, 15, 8, 12, 12, 18, 10, 14, 15, 20, 12, 16),\n  単価 = c(1000, 1000, 1500, 1500, 1000, 1000, 1500, 1500, 1000, 1000, 1500, 1500)\n)\n\nprint(sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         日付   店舗  商品 売上数量 単価\n1  2025-01-01 東京店 商品A       10 1000\n2  2025-01-01 大阪店 商品A       15 1000\n3  2025-01-01 東京店 商品B        8 1500\n4  2025-01-01 大阪店 商品B       12 1500\n5  2025-01-02 東京店 商品A       12 1000\n6  2025-01-02 大阪店 商品A       18 1000\n7  2025-01-02 東京店 商品B       10 1500\n8  2025-01-02 大阪店 商品B       14 1500\n9  2025-01-03 東京店 商品A       15 1000\n10 2025-01-03 大阪店 商品A       20 1000\n11 2025-01-03 東京店 商品B       12 1500\n12 2025-01-03 大阪店 商品B       16 1500\n```\n\n\n:::\n:::\n\n\n### 分析1: 売上金額の計算\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 売上金額を計算\nsales_with_amount <- sales |>\n  mutate(\n    売上金額 = 売上数量 * 単価\n  )\n\nprint(sales_with_amount)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         日付   店舗  商品 売上数量 単価 売上金額\n1  2025-01-01 東京店 商品A       10 1000    10000\n2  2025-01-01 大阪店 商品A       15 1000    15000\n3  2025-01-01 東京店 商品B        8 1500    12000\n4  2025-01-01 大阪店 商品B       12 1500    18000\n5  2025-01-02 東京店 商品A       12 1000    12000\n6  2025-01-02 大阪店 商品A       18 1000    18000\n7  2025-01-02 東京店 商品B       10 1500    15000\n8  2025-01-02 大阪店 商品B       14 1500    21000\n9  2025-01-03 東京店 商品A       15 1000    15000\n10 2025-01-03 大阪店 商品A       20 1000    20000\n11 2025-01-03 東京店 商品B       12 1500    18000\n12 2025-01-03 大阪店 商品B       16 1500    24000\n```\n\n\n:::\n:::\n\n\n### 分析2: 店舗ごとの売上集計\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 店舗ごとの売上を集計\nstore_summary <- sales_with_amount |>\n  group_by(店舗) |>\n  summarize(\n    総売上数量 = sum(売上数量),\n    総売上金額 = sum(売上金額),\n    平均売上数量 = mean(売上数量)\n    # group_by()を使わない場合\n    # .by = 店舗\n  )\n\nprint(store_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n  店舗   総売上数量 総売上金額 平均売上数量\n  <chr>       <dbl>      <dbl>        <dbl>\n1 大阪店         95     116000         15.8\n2 東京店         67      82000         11.2\n```\n\n\n:::\n:::\n\n\n### 分析3: 商品・店舗ごとの売上集計\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 商品と店舗の組み合わせで集計\nproduct_store_summary <- sales_with_amount |>\n  group_by(商品, 店舗) |>\n  summarize(\n    総売上金額 = sum(売上金額),\n    .groups = \"drop\"  # グループ化を自動で解除\n  ) |>\n  arrange(desc(総売上金額))\n\nprint(product_store_summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  商品  店舗   総売上金額\n  <chr> <chr>       <dbl>\n1 商品B 大阪店      63000\n2 商品A 大阪店      53000\n3 商品B 東京店      45000\n4 商品A 東京店      37000\n```\n\n\n:::\n:::\n\n\n### 分析4: 日付ごとの売上推移\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 日付ごとの売上推移\ndaily_sales <- sales_with_amount |>\n  group_by(日付) |>\n  summarize(\n    日次売上金額 = sum(売上金額),\n    日次販売数量 = sum(売上数量)\n  )\n\nprint(daily_sales)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  日付       日次売上金額 日次販売数量\n  <chr>             <dbl>        <dbl>\n1 2025-01-01        55000           45\n2 2025-01-02        66000           54\n3 2025-01-03        77000           63\n```\n\n\n:::\n:::\n\n\n## 応用テクニック\n\n### across()を使った複数列への同じ処理\n\n複数の列に同じ処理を適用したい場合は`across()`が便利です。\n\n少々使い方は難しいですが、例えば数値列（numeric型）すべての平均を品種ごとに計算する場合は以下のように書けます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# すべての数値列の平均を品種ごとに計算\niris |>\n  group_by(Species) |>\n  summarize(\n    across(where(is.numeric), mean)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  Species    Sepal.Length Sepal.Width Petal.Length Petal.Width\n  <fct>             <dbl>       <dbl>        <dbl>       <dbl>\n1 setosa             5.01        3.43         1.46       0.246\n2 versicolor         5.94        2.77         4.26       1.33 \n3 virginica          6.59        2.97         5.55       2.03 \n```\n\n\n:::\n:::\n\n\n`where()`は条件に合う列を選択するための関数で、`is.numeric`は数値列を選択する条件です。`across()`は、選択した列すべてに同じ関数（この場合は`mean`）を適用します。\n\nたくさんの列に同じ処理を適用したい場合は、`across()`を使うとコードがシンプルになります。\n\n### slice()で行を選択\n\nグループごとに上位N件を取得する場合は`slice()`が使えます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 品種ごとにSepal.Lengthが最も大きい3件を取得\niris |>\n  group_by(Species) |>\n  arrange(desc(Sepal.Length)) |>\n  slice(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 5\n# Groups:   Species [3]\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species   \n         <dbl>       <dbl>        <dbl>       <dbl> <fct>     \n1          5.8         4            1.2         0.2 setosa    \n2          5.7         4.4          1.5         0.4 setosa    \n3          5.7         3.8          1.7         0.3 setosa    \n4          7           3.2          4.7         1.4 versicolor\n5          6.9         3.1          4.9         1.5 versicolor\n6          6.8         2.8          4.8         1.4 versicolor\n7          7.9         3.8          6.4         2   virginica \n8          7.7         3.8          6.7         2.2 virginica \n9          7.7         2.6          6.9         2.3 virginica \n```\n\n\n:::\n:::\n\n\nSpeciesごとにSepal.Lengthが大きい順に並び替えた後、上位3件を取得しています。`slice()`は行番号で指定するため、`1:3`は上位3件を意味します。\n\nちなみに`ungroup()`をしていないので、`slice()`はグループごとに行を選択します。グループ化していない場合は、全体の上位3件を取得することになります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 全体の上位3件を取得（グループ化していない場合）\niris |>\n  group_by(Species) |>\n  arrange(desc(Sepal.Length)) |>\n  ungroup() |>\n  slice(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species  \n         <dbl>       <dbl>        <dbl>       <dbl> <fct>    \n1          7.9         3.8          6.4         2   virginica\n2          7.7         3.8          6.7         2.2 virginica\n3          7.7         2.6          6.9         2.3 virginica\n```\n\n\n:::\n:::\n\n\n## 練習問題\n\n::: {.callout-tip collapse=\"true\"}\n## 問題1: 新しい列の作成\n\n`iris`データで、がく片とFlowerの長さの合計を`Total.Length`という列名で追加してください。\n\n**解答例**\n```r\niris |>\n  mutate(Total.Length = Sepal.Length + Petal.Length) |>\n  select(Species, Sepal.Length, Petal.Length, Total.Length)\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## 問題2: グループごとの集計\n\n`iris`データで、品種ごとに`Petal.Width`の平均、最小値、最大値を計算してください。\n\n**解答例**\n```r\niris |>\n  group_by(Species) |>\n  summarize(\n    平均 = mean(Petal.Width),\n    最小値 = min(Petal.Width),\n    最大値 = max(Petal.Width)\n  )\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## 問題3: 実践的な分析\n\n以下の従業員データで、部署ごとの平均年齢と売上合計を計算し、売上合計の降順に並び替えてください。\n\n```r\nemployees <- data.frame(\n  名前 = c(\"田中\", \"佐藤\", \"鈴木\", \"高橋\", \"伊藤\", \"渡辺\"),\n  部署 = c(\"営業\", \"開発\", \"営業\", \"開発\", \"総務\", \"営業\"),\n  年齢 = c(25, 30, 35, 28, 42, 31),\n  売上 = c(1200, 1500, 980, 1350, 1100, 1450)\n)\n```\n\n**解答例**\n```r\nemployees |>\n  group_by(部署) |>\n  summarize(\n    平均年齢 = mean(年齢),\n    売上合計 = sum(売上)\n  ) |>\n  arrange(desc(売上合計))\n```\n:::\n\n## まとめ\n\nこの章では、dplyrの発展的な機能を学びました。\n\n- ✅ `mutate()`: 新しい列の作成・既存列の変換\n- ✅ `summarize()`: データの要約統計\n- ✅ `group_by()`: グループごとの集計\n- ✅ `count()`: データのカウント\n- ✅ これらを組み合わせた実践的なデータ分析\n\nこれで、データの読み込みから加工、集計まで一連の流れができるようになりました。次の章では、分析結果を視覚的に表現する方法を学びます。\n\n::: {.callout-note}\n## 次のステップ\n\n次の章「データ可視化入門 - ggplot2基礎」では、`ggplot2`パッケージを使ったグラフ作成を学びます。データの特徴を視覚的に理解し、他者に伝える力を身につけましょう。\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}