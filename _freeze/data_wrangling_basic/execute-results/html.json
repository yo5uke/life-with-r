{
  "hash": "e3ab91af6508e6cb5c6ca75343fbf325",
  "result": {
    "engine": "knitr",
    "markdown": "# データハンドリング基礎 - dplyr入門\n\n前章でデータの読み込み方を学びました。この章では、読み込んだデータを自在に操作する方法を学びます。\n\nデータ分析の実務では、生のデータをそのまま使うことはほとんどありません。必要な行だけを抽出したり、特定の列だけを選んだり、並び替えたりといった**データハンドリング**（データ操作）が必要になります。\n\n`dplyr`パッケージは、データハンドリングを直感的かつ効率的に行うための強力なツールです。これは前の章で使用した`readr`と同じく、`tidyverse`のコアパッケージの一つです。\n\n## 学習内容\n\nこの章を読み終えると、以下ができるようになります。\n\n- パイプ演算子（`%>%`もしくは`|>`）を使ったコードの書き方\n- `select()`: 必要な列だけを選択する\n- `filter()`: 条件に合う行だけを抽出する\n- `arrange()`: データを並び替える\n- 複数の操作を組み合わせる\n\n## tidyverseとは\n\n`dplyr`は`tidyverse`というパッケージ群の一部です。`tidyverse`は、データサイエンスのワークフローを統一的な文法で実現するパッケージの集まりです。\n\n```r\n# tidyverseをインストール（初回のみ）\ninstall.packages(\"tidyverse\")\n\n# tidyverseを読み込む（dplyrも含まれる）\nlibrary(tidyverse)\n```\n\n::: {.callout-note}\n## dplyrだけを使う場合\n\n`tidyverse`全体ではなく、`dplyr`だけを使いたい場合は以下のようにします。\n\n```r\nlibrary(dplyr)\n```\n\nただし、実務では`tidyverse`をまとめて読み込むことが多いです。\n:::\n\n## 練習用データの準備\n\nまずは練習用のデータを用意しましょう。R標準の`iris`データセット（アヤメの花のデータ）を使います。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\n# irisデータを読み込む\ndata(iris)\n\n# データの最初の数行を確認\nhead(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n`data(iris)`を実行すると`iris`としてデータが読み込まれます。\n\n`iris`データには以下の列があります。\n\n- `Sepal.Length`: がく片の長さ\n- `Sepal.Width`: がく片の幅\n- `Petal.Length`: 花弁の長さ\n- `Petal.Width`: 花弁の幅\n- `Species`: アヤメの品種（setosa, versicolor, virginica）\n\n## パイプ演算子\n\n`dplyr`を使う上で重要なのが**パイプ演算子**です。パイプ演算子には2種類あります。パイプの使い方を見る前に、まずはそれぞれのパイプ演算子について説明します。\n\n### `%>%`（magrittrパイプ）\n\n`tidyverse`に含まれる従来のパイプ演算子です。\n\n```r\n# パイプなし\nhead(iris, 10)\n\n# パイプあり\niris %>% head(10)\n```\n\n### `|>`（ネイティブパイプ）\n\nR 4.1.0以降で使える新しいパイプ演算子です。\n\n```r\n# ネイティブパイプ\niris |> head(10)\n```\n\n::: {.callout-tip}\n## どちらを使うべきか？\n\n基本的な使い方ではほぼ同じです。本サイトでは`|>`（ネイティブパイプ）を使いますが、`%>%`を使っても問題ありません。また、`%>%`に関しては`dplyr`を読み込まないと使えない点については注意してください。\n\nRStudioのキーボードショートカット`Ctrl` + `Shift` + `M`は、デフォルトで`%>%`を入力しますが、設定で`|>`に変更できます。  \nRStudioの場合はTools > Global Options > Code > Use native pipe operator (`|>`)にチェックを入れると、`Ctrl` + `Shift` + `M`で`|>`が入力されるようになります。  \nPositronの場合は{{< kbd win=\"Ctrl-,\" mac=\"⌘-,\" >}}で設定を開き、Positron.R.pipeを検索することで設定を変更することができます。\n:::\n\n### パイプ演算子の利点\n\nさて、パイプ演算子を使うとどんなメリットがあるのでしょうか？\n\nパイプ演算子を使うと、処理の流れが左から右（上から下）に読めるため、コードが理解しやすくなります。\n\n```r\n# パイプなし（内側から外側へ読む必要がある）\narrange(filter(select(iris, Species, Sepal.Length), Sepal.Length > 5), Sepal.Length)\n\n# パイプあり（上から下に読める）\niris |>\n  select(Species, Sepal.Length) |>\n  filter(Sepal.Length > 5) |>\n  arrange(Sepal.Length)\n```\n\nいかがでしょうか？パイプを使わない書き方だと、どの関数がどのデータに対して処理をしているのかを理解するために、内側から外側へとコードを読み解く必要があります。一方で、パイプを使うと、処理の流れが自然な順序で書かれているため、コードの意味が直感的に理解しやすくなります。\n\n仕組みを簡単に説明すると、パイプ演算子は左側のオブジェクトを右側の関数の第一引数^[関数の中で最初に指定する引数]に渡す役割を果たしています。つまり、`x |> f()`は`f(x)`と同じ意味になります。これにより、複数の関数を連続して適用する際に、コードが読みやすくなります。\n\n`dplyr`の関数は、第一引数にデータフレームを取るように設計されているので、起点となるデータフレームをパイプの左側に置いて、関数を順番に適用していくスタイルが自然になります。\n\n## select(): 列を選択する\n\nここからは、`dplyr`の基本的な関数を紹介していきます。まずは`select()`関数です。\n\n`select()`関数は、データフレームから必要な列だけを選び出します。\n\n### 基本的な使い方\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Species列とSepal.Length列だけを選択\nresult <- iris |>\n  select(Species, Sepal.Length)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Species Sepal.Length\n1  setosa          5.1\n2  setosa          4.9\n3  setosa          4.7\n4  setosa          4.6\n5  setosa          5.0\n6  setosa          5.4\n```\n\n\n:::\n:::\n\n\n### 列名の範囲指定\n\n`:`を使うと、連続した列をまとめて選択できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.LengthからPetal.Lengthまでの列を選択\nresult <- iris |>\n  select(Sepal.Length:Petal.Length)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length\n1          5.1         3.5          1.4\n2          4.9         3.0          1.4\n3          4.7         3.2          1.3\n4          4.6         3.1          1.5\n5          5.0         3.6          1.4\n6          5.4         3.9          1.7\n```\n\n\n:::\n:::\n\n\n### 列の除外\n\n`-`（マイナス）を使うと、指定した列以外を選択できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Width列を除外\nresult <- iris |>\n  select(-Sepal.Width)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Petal.Length Petal.Width Species\n1          5.1          1.4         0.2  setosa\n2          4.9          1.4         0.2  setosa\n3          4.7          1.3         0.2  setosa\n4          4.6          1.5         0.2  setosa\n5          5.0          1.4         0.2  setosa\n6          5.4          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n### 便利な選択関数\n\n`select()`では、列名のパターンマッチングもできます。\n\n```r\n# \"Sepal\"で始まる列を選択\niris |>\n  select(starts_with(\"Sepal\"))\n\n# \"Width\"で終わる列を選択\niris |>\n  select(ends_with(\"Width\"))\n\n# \"Length\"を含む列を選択\niris |>\n  select(contains(\"Length\"))\n```\n\n`starts_with()`は列名が指定した文字列で始まる列を選択し、`ends_with()`は列名が指定した文字列で終わる列を選択します。`contains()`は列名に指定した文字列が含まれる列を選択します。\n\n## filter(): 行を抽出する\n\n`filter()`関数は、条件に合う行だけを抽出します。\n\n### 基本的な使い方\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthが5より大きい行だけを抽出\nresult <- iris |>\n  filter(Sepal.Length > 5)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          5.4         3.9          1.7         0.4  setosa\n3          5.4         3.7          1.5         0.2  setosa\n4          5.8         4.0          1.2         0.2  setosa\n5          5.7         4.4          1.5         0.4  setosa\n6          5.4         3.9          1.3         0.4  setosa\n```\n\n\n:::\n:::\n\n\n### 複数の条件\n\n複数の条件を組み合わせることもできます。カンマで指定する方法と論理演算子を使う方法がありますが、どちらも同じ意味になります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthが5より大きく、かつSpeciesがsetosaの行\nresult <- iris |>\n  filter(Sepal.Length > 5, Species == \"setosa\")\n\n# 上と同じ（,はANDの意味）\n# iris |>\n#   filter(Sepal.Length > 5 & Species == \"setosa\")\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          5.4         3.9          1.7         0.4  setosa\n3          5.4         3.7          1.5         0.2  setosa\n4          5.8         4.0          1.2         0.2  setosa\n5          5.7         4.4          1.5         0.4  setosa\n6          5.4         3.9          1.3         0.4  setosa\n```\n\n\n:::\n:::\n\n\n### OR条件\n\n`|`を使うと「または」の条件を指定できます。`%in%`を使うと、複数の値のいずれかに一致する条件を簡単に書くことができます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Speciesがsetosaまたはvirginicaの行\nresult <- iris |>\n  filter(Species == \"setosa\" | Species == \"virginica\")\n\n# 上と同じ（%in%を使った書き方）\n# iris |>\n#   filter(Species %in% c(\"setosa\", \"virginica\"))\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n### 否定条件\n\n`!`を使うと、条件に合わない行を抽出できます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthが5以下の行を抽出\nresult <- iris |>\n  filter(!(Sepal.Length > 5))\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.9         3.0          1.4         0.2  setosa\n2          4.7         3.2          1.3         0.2  setosa\n3          4.6         3.1          1.5         0.2  setosa\n4          5.0         3.6          1.4         0.2  setosa\n5          4.6         3.4          1.4         0.3  setosa\n6          5.0         3.4          1.5         0.2  setosa\n```\n\n\n:::\n:::\n\n\nこれはSepal.Lengthが5より大きい行を除外する、という意味になります。否定したい条件を`!()`で括ることで、条件に合わない行を抽出できます。\n\n### filter_out(): 特定の行を除外する\n\ndplyr 1.2.0以降では、`filter_out()`関数を使って特定の条件に合う行を除外することもできます。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthが5より大きい行を除外\nresult <- iris |>\n  filter_out(Sepal.Length > 5)\n\n# 以下と同義\n# iris |>\n#   filter(!(Sepal.Length > 5))\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.9         3.0          1.4         0.2  setosa\n2          4.7         3.2          1.3         0.2  setosa\n3          4.6         3.1          1.5         0.2  setosa\n4          5.0         3.6          1.4         0.2  setosa\n5          4.6         3.4          1.4         0.3  setosa\n6          5.0         3.4          1.5         0.2  setosa\n```\n\n\n:::\n:::\n\n\n除外したい条件を直接`filter_out()`に指定することで、条件に合う行を簡単に除外できるようになっています。\n\n::: {.callout-note}\n## 比較演算子と論理演算子\n\n**比較演算子**\n- `==`: 等しい\n- `!=`: 等しくない\n- `>`: より大きい\n- `>=`: 以上\n- `<`: より小さい\n- `<=`: 以下\n\n**論理演算子**\n- `&`: かつ（AND）\n- `|`: または（OR）\n- `!`: 否定（NOT）\n\n注意: 等しいは`==`（イコール2つ）です。`=`（イコール1つ）は代入演算子なので注意してください。\n:::\n\n## arrange(): データを並び替える\n\n`arrange()`関数は、指定した列でデータを並び替えます。\n\n### 昇順（小さい順）\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthの昇順に並び替え\nresult <- iris |>\n  arrange(Sepal.Length)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.3         3.0          1.1         0.1  setosa\n2          4.4         2.9          1.4         0.2  setosa\n3          4.4         3.0          1.3         0.2  setosa\n4          4.4         3.2          1.3         0.2  setosa\n5          4.5         2.3          1.3         0.3  setosa\n6          4.6         3.1          1.5         0.2  setosa\n```\n\n\n:::\n:::\n\n\n### 降順（大きい順）\n\n`desc()`関数を使うと降順になります。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sepal.Lengthの降順に並び替え\nresult <- iris |>\n  arrange(desc(Sepal.Length))\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n1          7.9         3.8          6.4         2.0 virginica\n2          7.7         3.8          6.7         2.2 virginica\n3          7.7         2.6          6.9         2.3 virginica\n4          7.7         2.8          6.7         2.0 virginica\n5          7.7         3.0          6.1         2.3 virginica\n6          7.6         3.0          6.6         2.1 virginica\n```\n\n\n:::\n:::\n\n\n### 複数の列で並び替え\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# まずSpeciesで並び替え、次にその中でSepal.Lengthで並び替え\nresult <- iris |>\n  arrange(Species, Sepal.Length)\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          4.3         3.0          1.1         0.1  setosa\n2          4.4         2.9          1.4         0.2  setosa\n3          4.4         3.0          1.3         0.2  setosa\n4          4.4         3.2          1.3         0.2  setosa\n5          4.5         2.3          1.3         0.3  setosa\n6          4.6         3.1          1.5         0.2  setosa\n```\n\n\n:::\n:::\n\n\n## 複数の操作を組み合わせる\n\nパイプ演算子を使うと、複数の操作を順番に実行できます。\n\n### 実践例1: 基本的な組み合わせ\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setosa品種のデータから、\n# がく片の列だけを選び、\n# がく片の長さが5以上のものを抽出し、\n# 長さの降順に並び替える\n\nresult <- iris |>\n  filter(Species == \"setosa\") |>\n  select(Species, Sepal.Length, Sepal.Width) |>\n  filter(Sepal.Length >= 5) |>\n  arrange(desc(Sepal.Length))\n\nhead(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Species Sepal.Length Sepal.Width\n1  setosa          5.8         4.0\n2  setosa          5.7         4.4\n3  setosa          5.7         3.8\n4  setosa          5.5         4.2\n5  setosa          5.5         3.5\n6  setosa          5.4         3.9\n```\n\n\n:::\n:::\n\n\n### 実践例2: 実務的なデータ処理\n\n従業員データを想定した例です。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# サンプルデータの作成\nemployees <- data.frame(\n  名前 = c(\n    \"田中太郎\",\n    \"佐藤花子\",\n    \"鈴木一郎\",\n    \"高橋次郎\",\n    \"伊藤三郎\",\n    \"渡辺四郎\"\n  ),\n  部署 = c(\"営業\", \"開発\", \"営業\", \"開発\", \"総務\", \"営業\"),\n  年齢 = c(25, 30, 35, 28, 42, 31),\n  売上 = c(1200, 1500, 980, 1350, 1100, 1450)\n)\n\n# 営業部の社員で、売上が1000以上の人を、売上の降順に表示\n営業成績 <- employees |>\n  filter(部署 == \"営業\") |>\n  filter(売上 >= 1000) |>\n  select(名前, 売上) |>\n  arrange(desc(売上))\n\nprint(営業成績)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      名前 売上\n1 渡辺四郎 1450\n2 田中太郎 1200\n```\n\n\n:::\n:::\n\n\n## 結果の保存\n\nパイプ処理の結果は、`<-`で変数に代入できます。\n\n```r\n# 処理結果を変数に保存\nsetosa_data <- iris |>\n  filter(Species == \"setosa\") |>\n  select(Sepal.Length, Sepal.Width)\n\n# CSVファイルとして保存\n# dplyrしか読み込んでいない場合はreadrも読み込む\n# library(readr)\nwrite_csv(setosa_data, \"data/setosa_only.csv\")\n```\n\n## 練習問題\n\nここまで学んだ内容を確認しましょう。\n\n::: {.callout-tip collapse=\"true\"}\n## 問題1: 列の選択\n\n`iris`データから、`Petal.Length`、`Petal.Width`、`Species`の3列だけを選択してください。\n\n**解答例**\n```r\niris |>\n  select(Petal.Length, Petal.Width, Species)\n\n# または\niris |>\n  select(Petal.Length:Species)\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## 問題2: 条件抽出\n\n`iris`データから、`Petal.Length`が3以上5以下の行を抽出してください。\n\n**解答例**\n```r\niris |>\n  filter(Petal.Length >= 3, Petal.Length <= 5)\n\n# または\niris |>\n  filter(Petal.Length >= 3 & Petal.Length <= 5)\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## 問題3: 複数操作の組み合わせ\n\n`iris`データから以下の処理を行ってください。\n\n1. `Species`が\"setosa\"と\"versicolor\"である行を抽出\n2. `Sepal`で始まる列のみを選択\n3. `Sepal.Length`の降順に並び替え\n4. 最初の10行だけを表示\n\n**解答例**\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- iris |>\n  filter(Species %in% c(\"setosa\", \"versicolor\")) |>\n  select(starts_with(\"Sepal\")) |>\n  arrange(desc(Sepal.Length)) |>\n  head(10)\n\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Sepal.Length Sepal.Width\n1           7.0         3.2\n2           6.9         3.1\n3           6.8         2.8\n4           6.7         3.1\n5           6.7         3.0\n6           6.7         3.1\n7           6.6         2.9\n8           6.6         3.0\n9           6.5         2.8\n10          6.4         3.2\n```\n\n\n:::\n:::\n\n\n**参考: filter_outを使った書き方**\n```r\n# virginicaを除外する方法でも可能\niris |>\n  filter_out(Species == \"virginica\") |>\n  select(starts_with(\"Sepal\")) |>\n  arrange(desc(Sepal.Length)) |>\n  head(10)\n```\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## 問題4: 実践的な問題\n\n以下のデータを作成し、「開発部で年齢が30歳未満の社員の名前と年齢」を抽出してください。\n\n```r\nemployees <- data.frame(\n  名前 = c(\"田中\", \"佐藤\", \"鈴木\", \"高橋\", \"伊藤\"),\n  部署 = c(\"営業\", \"開発\", \"営業\", \"開発\", \"総務\"),\n  年齢 = c(25, 30, 35, 28, 42)\n)\n```\n\n**解答例**\n```r\nemployees |>\n  filter(部署 == \"開発\", 年齢 < 30) |>\n  select(名前, 年齢)\n```\n:::\n\n## まとめ\n\nこの章では、`dplyr`の基本的な関数を学びました。\n\n- ✅ パイプ演算子（`|>`または`%>%`）で処理を繋げる\n- ✅ `select()`: 必要な列だけを選択\n- ✅ `filter()`: 条件に合う行を抽出\n- ✅ `arrange()`: データを並び替え\n- ✅ 複数の操作を組み合わせて実務的なデータ処理\n\nこれらは、データ分析で最も頻繁に使う操作です。次の章では、さらに高度な操作（新しい列の作成、集計など）を学びます。\n\n::: {.callout-note}\n## 次のステップ\n\n次の章「データハンドリング応用 - dplyr発展」では、以下を学びます。\n\n- `mutate()`: 新しい列の作成・計算\n- `summarize()`: データの要約統計量\n- `group_by()`: グループごとの集計\n\nこれらをマスターすれば、ほとんどのデータ処理に対応できるようになります。\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}